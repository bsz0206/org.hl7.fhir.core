package org.hl7.fhir.r5.profiles;

import java.util.List;
import java.util.ArrayList;
import javax.annotation.Nullable;
import java.util.Date;


import org.hl7.fhir.r5.context.IWorkerContext;
import org.hl7.fhir.r5.model.*;
import org.hl7.fhir.r5.profilemodel.PEBuilder;
import org.hl7.fhir.r5.profilemodel.PEInstance;
import org.hl7.fhir.r5.profilemodel.PEBuilder.PEElementPropertiesPolicy;
import org.hl7.fhir.r5.profilemodel.gen.PEGeneratedBase;
import java.util.List;
import java.util.ArrayList;
import javax.annotation.Nullable;
import java.util.Date;


import org.hl7.fhir.r5.context.IWorkerContext;
import org.hl7.fhir.r5.model.*;
import org.hl7.fhir.r5.profilemodel.PEBuilder;
import org.hl7.fhir.r5.profilemodel.PEInstance;
import org.hl7.fhir.r5.profilemodel.PEBuilder.PEElementPropertiesPolicy;
import org.hl7.fhir.r5.profilemodel.gen.PEGeneratedBase;


// Generated by the HAPI Java Profile Generator, Sun, Aug 20, 2023 19:05+1000

/**
 * Test CodeableConcept Profile.
 *
 */
public class TestDatatypeProfile extends PEGeneratedBase {

  private static final String CANONICAL_URL = "http://hl7.org/fhir/test/StructureDefinition/pe-profile2|0.1";

  private List<Coding> codings;// @NotNull  // Code defined by a terminology system
  private List<Coding> snomedcts;// @NotNull  // Code defined by a terminology system
  private List<Coding> loincs;  // Code defined by a terminology system
  private String text;// @NotNull  // Plain text representation of the concept

  /**
   * Parameter-less constructor. If you use this, the fixed values won't be filled 
   * out - they'll be missing. They'll be filled in if/when you call build, so they 
   * won't be missing from the resource, only from this particular object model
   *
   */
  public TestDatatypeProfile() {
    // todo
  }

  /**
   * Used when loading other models 
   *
   */
  public static TestDatatypeProfile fromSource(PEInstance source) {
    TestDatatypeProfile theThing = new TestDatatypeProfile();
    theThing.workerContext = source.getContext();
    theThing.load(source);
    return theThing;
  }

  public void load(PEInstance src) {
    clear();
    for (PEInstance item : src.children("codings")) {
      codings.add((Coding) item.asDataType());
    }
    for (PEInstance item : src.children("snomedcts")) {
      snomedcts.add((Coding) item.asDataType());
    }
    for (PEInstance item : src.children("loincs")) {
      loincs.add((Coding) item.asDataType());
    }
    if (src.hasChild("text")) {
      text = ((StringType) src.child("text").asDataType()).getValue();
    }

  }

  public void save(PEInstance tgt, boolean nulls) {

  }

  /**
   * Test CodeableConcept Profile.
   *
   */
  public List<Coding> getCodings() {
    if (codings == null) { codings = new ArrayList<>(); }
    return codings;
  }

  public boolean hasCodings() {
    return codings != null && !codings.isEmpty();
  }

  public Coding addCoding() {
    Coding theThing = new Coding();
    getCodings().add(theThing);
    return theThing;
  }

  public boolean hasCoding(Coding item) {
    return hasCodings() && codings.contains(item);
  }

  public void removeCoding(Coding item) {
    if (hasCoding(item)) {
      codings.remove(item);
    }
  }


  /**
   * Test CodeableConcept Profile.
   *
   */
  public List<Coding> getSnomedcts() {
    if (snomedcts == null) { snomedcts = new ArrayList<>(); }
    return snomedcts;
  }

  public boolean hasSnomedcts() {
    return snomedcts != null && !snomedcts.isEmpty();
  }

  public Coding addSnomedct() {
    Coding theThing = new Coding();
    getSnomedcts().add(theThing);
    return theThing;
  }

  public boolean hasSnomedct(Coding item) {
    return hasSnomedcts() && snomedcts.contains(item);
  }

  public void removeSnomedct(Coding item) {
    if (hasSnomedct(item)) {
      snomedcts.remove(item);
    }
  }


  /**
   * Test CodeableConcept Profile.
   *
   */
  public List<Coding> getLoincs() {
    if (loincs == null) { loincs = new ArrayList<>(); }
    return loincs;
  }

  public boolean hasLoincs() {
    return loincs != null && !loincs.isEmpty();
  }

  public Coding addLoinc() {
    Coding theThing = new Coding();
    getLoincs().add(theThing);
    return theThing;
  }

  public boolean hasLoinc(Coding item) {
    return hasLoincs() && loincs.contains(item);
  }

  public void removeLoinc(Coding item) {
    if (hasLoinc(item)) {
      loincs.remove(item);
    }
  }


  /**
   * Test CodeableConcept Profile.
   *
   */
  public String getText() {
    return text;
  }

  public TestDatatypeProfile setText(String value) {
    this.text = value;
    return this;
  }

  public boolean hasText() {
    return text != null;
  }



  public void clear() {
    codings = null;
    snomedcts = null;
    loincs = null;
    text = null;

  }

}
